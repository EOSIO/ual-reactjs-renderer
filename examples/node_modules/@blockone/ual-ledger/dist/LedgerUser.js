"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const eosjs_ledger_signature_provider_1 = require("@blockone/eosjs-ledger-signature-provider");
const universal_authenticator_library_1 = require("@blockone/universal-authenticator-library");
const eosjs_1 = require("eosjs");
const text_encoding_1 = require("text-encoding");
const interfaces_1 = require("./interfaces");
const UALLedgerError_1 = require("./UALLedgerError");
class LedgerUser extends universal_authenticator_library_1.User {
    constructor(chain, accountName, requestPermission) {
        super();
        this.chain = chain;
        this.accountName = accountName;
        this.requestPermission = requestPermission;
        this.api = null;
        this.rpc = null;
        if (typeof (TextEncoder) !== 'undefined') {
            this.textEncoder = TextEncoder;
            this.textDecoder = TextDecoder;
        }
        else {
            this.textEncoder = text_encoding_1.TextEncoder;
            this.textDecoder = text_encoding_1.TextDecoder;
        }
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            this.signatureProvider = new eosjs_ledger_signature_provider_1.SignatureProvider();
            const rpcEndpoint = this.chain.rpcEndpoints[0];
            const rpcEndpointString = `${rpcEndpoint.protocol}://${rpcEndpoint.host}:${rpcEndpoint.port}`;
            this.rpc = new eosjs_1.JsonRpc(rpcEndpointString);
            this.api = new eosjs_1.Api({
                rpc: this.rpc,
                signatureProvider: this.signatureProvider,
                textEncoder: new this.textEncoder(),
                textDecoder: new this.textDecoder(),
            });
        });
    }
    signTransaction(transaction, { broadcast = true, blocksBehind = 3, expireSeconds = 30 }) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const completedTransaction = this.api && (yield this.api.transact(transaction, { broadcast, blocksBehind, expireSeconds }));
                return this.returnEosjsTransaction(broadcast, completedTransaction);
            }
            catch (e) {
                const message = e.message ? e.message : 'Unable to sign transaction';
                const type = universal_authenticator_library_1.UALErrorType.Signing;
                const cause = e;
                throw new UALLedgerError_1.UALLedgerError(message, type, cause);
            }
        });
    }
    signArbitrary() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new UALLedgerError_1.UALLedgerError(`${interfaces_1.Name} does not currently support signArbitrary`, universal_authenticator_library_1.UALErrorType.Unsupported, null);
        });
    }
    verifyKeyOwnership(_) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new UALLedgerError_1.UALLedgerError(`${interfaces_1.Name} does not currently support verifyKeyOwnership`, universal_authenticator_library_1.UALErrorType.Unsupported, null);
        });
    }
    getAccountName() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.accountName;
        });
    }
    getChainId() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.chain.chainId;
        });
    }
    getKeys() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const keys = yield this.signatureProvider.getAvailableKeys(this.requestPermission);
                return keys;
            }
            catch (error) {
                const message = `Unable to getKeys for account ${this.accountName}.
        Please make sure your ledger device is connected and unlocked`;
                const type = universal_authenticator_library_1.UALErrorType.DataRequest;
                const cause = error;
                throw new UALLedgerError_1.UALLedgerError(message, type, cause);
            }
        });
    }
    isAccountValid() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const account = this.rpc && (yield this.rpc.get_account(this.accountName));
                const actualKeys = this.extractAccountKeys(account);
                const authorizationKeys = yield this.getKeys();
                return actualKeys.filter((key) => {
                    return authorizationKeys.indexOf(key) !== -1;
                }).length > 0;
            }
            catch (e) {
                if (e.constructor.name === 'UALLedgerError') {
                    throw e;
                }
                const message = `Account validation failed for account ${this.accountName}.`;
                const type = universal_authenticator_library_1.UALErrorType.Validation;
                const cause = e;
                throw new UALLedgerError_1.UALLedgerError(message, type, cause);
            }
        });
    }
    extractAccountKeys(account) {
        const keySubsets = account.permissions.map((permission) => permission.required_auth.keys.map((key) => key.key));
        let keys = [];
        for (const keySubset of keySubsets) {
            keys = keys.concat(keySubset);
        }
        return keys;
    }
}
exports.LedgerUser = LedgerUser;
